name: CD – Build, Push & Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
        inputs:
          caller_repo:
            description: "Who triggered"
            required: false
          image_tag:
            description: "Optional image tag"
            required: false   

permissions:
  contents: read
  packages: write

env:
  REMOTE_DIR: /srv/mjsec

  # ----- 도메인/레포 기본값 -----
  ORG:         ${{ vars.ORG }}
  REPO:        ${{ vars.REPO }}
  DOMAIN:      ${{ vars.DOMAIN }}
  EMAIL:       ${{ vars.EMAIL }}
  WIKI_DOMAIN: ${{ vars.WIKI_DOMAIN }}    # 비어있으면 wiki.${DOMAIN}로 fallback

  # ----- Docker Hub 네임스페이스(원격에서 pull용) -----
  DOCKERHUB_USER: ${{ vars.DOCKERHUB_USER }}

  # ----- Compose/템플릿 (로컬 경로) -----
  COMPOSE_FILE:              ./mjsec-frontend/docker-compose.prod.yaml
  NGINX_HTTP_TEMPLATE_PATH:  ./mjsec-frontend/docker/nginx/default.http.conf.template
  NGINX_HTTPS_TEMPLATE_PATH: ./mjsec-frontend/docker/nginx/default.https.conf.template

jobs:
  #############################################################################
  # 1) Build & Push (GHCR) — 홍보용 웹사이트(app)만 빌드/푸시
  #############################################################################
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      ghcr-tags:    ${{ steps.meta_app.outputs.tags }}
      ghcr-digest:  ${{ steps.build_app.outputs.digest }}

    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      # ----- GHCR (메인 app) -----
      - name: Login to ghcr.io
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image metadata (app → GHCR)
        id: meta_app
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build & push app image (GHCR)
        id: build_app
        uses: docker/build-push-action@v5
        with:
          context: ./mjsec-frontend
          file:    ./mjsec-frontend/Dockerfile
          push:    true
          tags:    ${{ steps.meta_app.outputs.tags }}
          cache-from: type=gha
          cache-to:   type=gha,mode=max

  #############################################################################
  # 2) Deploy (SSH + Docker Compose)
  #############################################################################
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Add host key
        run: |
          ssh-keyscan -H -p ${{ secrets.SSH_PORT }} ${{ secrets.HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "echo OK"

      # Docker Hub에서 최신 태그 1개씩 조회 (lms-back / lms-front)
      - name: Resolve latest Docker Hub tags (lms-back / lms-front)
        env:
          DH_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          DH_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          FALLBACK_USER: ${{ env.DOCKERHUB_USER }}
        run: |
          set -euo pipefail
          sudo apt-get update && sudo apt-get install -y jq

          USERNAME="${DH_USER:-$FALLBACK_USER}"
          if [ -z "$USERNAME" ]; then
            echo "Docker Hub username is missing (set secrets.DOCKERHUB_USERNAME or vars.DOCKERHUB_USER)."
            exit 1
          fi
          if [ -z "${DH_TOKEN:-}" ]; then
            echo "Docker Hub token missing (set secrets.DOCKERHUB_TOKEN)."
            exit 1
          fi

          TOKEN="$(curl -s -H "Content-Type: application/json" \
            -d "{\"username\":\"${USERNAME}\",\"password\":\"${DH_TOKEN}\"}" \
            https://hub.docker.com/v2/users/login/ | jq -r .token)"
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "Failed to get Docker Hub JWT"; exit 1
          fi

          API="https://hub.docker.com/v2/repositories"
          LATEST_BACK=$(curl -s -H "Authorization: JWT ${TOKEN}" \
            "${API}/${USERNAME}/mjsec-lms-back/tags?page_size=1&ordering=last_updated" \
            | jq -r '.results[0].name')
          LATEST_FRONT=$(curl -s -H "Authorization: JWT ${TOKEN}" \
            "${API}/${USERNAME}/mjsec-lms-front/tags?page_size=1&ordering=last_updated" \
            | jq -r '.results[0].name')

          # 안전한 fallback
          if [ -z "$LATEST_BACK" ] || [ "$LATEST_BACK" = "null" ]; then LATEST_BACK="latest"; fi
          if [ -z "$LATEST_FRONT" ] || [ "$LATEST_FRONT" = "null" ]; then LATEST_FRONT="latest"; fi

          echo "LATEST_BACK=$LATEST_BACK"
          echo "LATEST_FRONT=$LATEST_FRONT"

          {
            echo "LATEST_BACK=$LATEST_BACK"
            echo "LATEST_FRONT=$LATEST_FRONT"
          } >> "$GITHUB_ENV"

      # 1) 원격 디렉터리 준비 + .env 업로드 (LMS 변수 포함)
      - name: Prepare remote dir & .env
        run: |
          # WIKI_DOMAIN fallback
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          # 디렉터리 생성
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} \
            "mkdir -p '${{ env.REMOTE_DIR }}'/nginx '${{ env.REMOTE_DIR }}'/certbot/config '${{ env.REMOTE_DIR }}'/certbot/www '${{ env.REMOTE_DIR }}'/certbot/logs '${{ env.REMOTE_DIR }}'/wikijs/db"

          # .env 작성 (Docker Hub 최신 태그 사용)
          TMP_ENV=$(mktemp)
          cat > "$TMP_ENV" <<EOT
          ORG=${{ env.ORG }}
          REPO=${{ env.REPO }}
          DOMAIN=${{ env.DOMAIN }}
          EMAIL=${{ env.EMAIL }}
          WIKI_DOMAIN=$WIKI_DOMAIN

          # Docker Hub (pull용 네임스페이스 + 태그)
          DOCKERHUB_USER=${{ env.DOCKERHUB_USER }}
          LMS_BACK_TAG=${LATEST_BACK:-latest}
          LMS_FRONT_TAG=${LATEST_FRONT:-latest}

          # Wiki.js
          WIKI_DB_PASSWORD=${{ secrets.WIKI_DB_PASSWORD }}
          WIKI_API_TOKEN =  ${{ secrets.WIKI_API_TOKEN }}
          WIKI_DOMAIN: ${{ secrets.WIKI_DOMAIN }}
          WIKI_GROUP_ID: ${{ secrets.WIKI_GROUP_ID }}
          
          # LMS RUNTIME
          LMS_MYSQL_ROOT_PASSWORD=${{ secrets.LMS_MYSQL_ROOT_PASSWORD }}
          LMS_MYSQL_DATABASE=${{ vars.LMS_MYSQL_DATABASE }}
          LMS_MYSQL_USER=${{ vars.LMS_MYSQL_USER }}
          LMS_MYSQL_PASSWORD=${{ secrets.LMS_MYSQL_PASSWORD }}

          GMAIL_USERNAME=${{ vars.GMAIL_USERNAME }}
          GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          ADMIN_NUMBER=${{ vars.ADMIN_NUMBER }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          SPRING_PROFILES_ACTIVE=${{ vars.SPRING_PROFILES_ACTIVE || 'prod' }}

          # certbot 옵션
          CERTBOT_EXTRA_ARGS=--expand
          EOT
          scp -P ${{ secrets.SSH_PORT }} "$TMP_ENV" ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/.env"
          rm -f "$TMP_ENV"

      # 1-b) 원격 레지스트리 로그인 (필요 시)
      - name: Log in to ghcr.io on remote host (optional)
        run: |
          if [ -n "${{ secrets.GHCR_PAT }}" ]; then
            ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" \
              "echo '${{ secrets.GHCR_PAT }}' | docker login ghcr.io -u ${{ github.actor }} --password-stdin"
          fi

      - name: Log in to Docker Hub on remote host (optional)
        run: |
          if [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" \
              "echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u '${{ secrets.DOCKERHUB_USERNAME || env.DOCKERHUB_USER }}' --password-stdin"
          fi

      # 2) HTTP-only 템플릿 & Compose 업로드 (원격 파일명은 docker-compose.prod.yaml 로 고정)
      - name: Upload HTTP-only Nginx template and compose
        run: |
          scp -P ${{ secrets.SSH_PORT }} "${{ env.NGINX_HTTP_TEMPLATE_PATH }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"
          scp -P ${{ secrets.SSH_PORT }} "${{ env.COMPOSE_FILE }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/docker-compose.prod.yaml"

      # 3) HTTP-only 스택(Nginx+App) 기동
      - name: Start HTTP-only stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml down --remove-orphans || true &&
            docker compose -f docker-compose.prod.yaml up -d nginx app
          "

      # 4) HTTP 응답 대기
      - name: Wait for HTTP
        run: |
          for i in {1..24}; do
            if curl -sSf -m 5 http://${{ env.DOMAIN }} >/dev/null 2>&1; then
              echo 'HTTP OK'; break
            fi
            echo "...waiting HTTP (${i}/24)"; sleep 5
          done

      # 5) 인증서 발급/갱신 (메인 + WIKI 서브도메인)
      - name: Issue / Renew SSL (DOMAIN + WIKI_DOMAIN)
        run: |
          set -euo pipefail

          # GitHub Actions 표현식에 기본값(:-) 쓰지 말고 bash에서 처리
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then
            WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"
          fi
          echo "Using WIKI_DOMAIN=$WIKI_DOMAIN"

          # 원격 실행 (종료코드 캡처)
          set +e
          ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" 'bash -se' <<'EOF'
            set -Eeuo pipefail
            cd '${{ env.REMOTE_DIR }}'

            # 필요 시에만 발급/갱신 시도 (30일 이상 남으면 skip)
            CERT_DIR="certbot/config/live/${{ env.DOMAIN }}"
            PEM="$CERT_DIR/fullchain.pem"
            if [ -f "$PEM" ] && openssl x509 -in "$PEM" -noout -checkend $((30*24*3600)); then
              echo "✅ Certificate valid > 30 days. Skipping issuance."
              exit 0
            fi

            # 재시도(최대 5회)
            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: running certbot..."
              if docker compose -f docker-compose.prod.yaml run --rm certbot; then
                echo "Certbot success."
                exit 0
              fi
              sleep $((i*15))
            done

            echo "Certbot failed after retries."
            exit 1
          EOF
          RC=$?
          set -e

          echo "Remote exit code: $RC"
          exit $RC

      # 6) SSL helper 파일 확보
      - name: Provide SSL helper files for nginx
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yaml run --rm --entrypoint "" certbot sh -euxc '
              OPTIONS=/etc/letsencrypt/options-ssl-nginx.conf
              DHPARAM=/etc/letsencrypt/ssl-dhparams.pem
              mkdir -p /etc/letsencrypt

              if [ ! -f "$OPTIONS" ]; then
                SRC=$(find /usr /opt -maxdepth 7 -type f -name options-ssl-nginx.conf | head -n1 || true)
                if [ -n "$SRC" ]; then cp "$SRC" "$OPTIONS"
                elif command -v curl >/dev/null; then
                  curl -fsSL https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf -o "$OPTIONS"
                fi
              fi
              if [ ! -s "$OPTIONS" ]; then
                printf "%s\n" \
                  "ssl_session_cache   shared:SSL:10m;" \
                  "ssl_session_timeout 1h;" \
                  "ssl_prefer_server_ciphers on;" \
                  "ssl_protocols TLSv1.2 TLSv1.3;" \
                  "ssl_ciphers EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH;" \
                  > "$OPTIONS"
              fi
              if [ ! -f "$DHPARAM" ]; then openssl dhparam -out "$DHPARAM" 2048; fi
            '
          EOF
      # 8) 최신 이미지 pull & 전체 스택 기동 
      - name: Deploy latest stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml pull &&
            docker compose -f docker-compose.prod.yaml up -d --remove-orphans
          "

      # 7) HTTPS 템플릿 업로드 (적용은 아직 X)
      - name: Upload HTTPS Nginx template
        run: |
          scp -P ${{ secrets.SSH_PORT }} "${{ env.NGINX_HTTPS_TEMPLATE_PATH }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"

      

      # 9) (지금) HTTPS conf 생성 + Nginx reload  ✅ 스택 기동 이후로 이동
      - name: Apply HTTPS config & reload nginx (after stack is up)
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yaml exec nginx sh -exc '
              : "${WIKI_DOMAIN:=wiki.$DOMAIN}";
              envsubst '\''$DOMAIN $WIKI_DOMAIN'\'' \
                < /etc/nginx/templates/default.conf.template \
                > /etc/nginx/conf.d/default.conf
              nginx -t
              nginx -s reload
            '
          EOF

      # 10) HTTPS 검증 (도메인/위키 + LMS 프론트/백엔드 경로)
      - name: Verify HTTPS
        run: |
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          check() { host="$1"; path="$2"; label="$3";
            echo "Check https://$host$path ($label)"
            for i in {1..12}; do
              if curl -sSf -m 8 "https://$host$path" >/dev/null 2>&1; then
                echo "HTTPS OK: $host$path"; return 0
              fi
              echo "...waiting HTTPS (${i}/12) for $host$path"; sleep 10
            done
            return 1
          }

          check "${{ env.DOMAIN }}" "/"        "root(app)"
          check "$WIKI_DOMAIN"        "/"        "wiki"
          check "${{ env.DOMAIN }}" "/lms/"     "lms-front" || true
          curl -s -o /dev/null -m 5 "https://${{ env.DOMAIN }}/lms/api/actuator/health" \
            && echo "OK: actuator" || echo "NOTE: actuator not enabled (skip)"

      # 11) 오래된 이미지 정리
      - name: Prune images
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} \
            "docker image prune -f --filter 'until=24h' || true"

  #############################################################################
  # 3) 알림
  #############################################################################
  notify:
    needs: [ build-and-push, deploy ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Success notice
        if: success()
        run: echo "✅  Deployed to ${{ env.DOMAIN }} (+ wiki, + /lms)"

      - name: Failure notice
        if: failure()
        run: echo "❌  Deployment to ${{ env.DOMAIN }} failed"
