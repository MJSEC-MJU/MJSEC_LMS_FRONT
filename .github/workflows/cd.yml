name: CD ‚Äì Build, Push & Deploy to Production

on:
  push:
    branches: [ main ]
    # tags: [ 'v*.*.*' ]

permissions:
  contents: read
  packages: write

env:
  REMOTE_DIR: /srv/mjsec

  # ----- ÎèÑÎ©îÏù∏/Î†àÌè¨ Í∏∞Î≥∏Í∞í -----
  ORG:         ${{ vars.ORG }}
  REPO:        ${{ vars.REPO }}
  DOMAIN:      ${{ vars.DOMAIN }}
  EMAIL:       ${{ vars.EMAIL }}
  WIKI_DOMAIN: ${{ vars.WIKI_DOMAIN }}    # ÎπÑÏñ¥ÏûàÏúºÎ©¥ wiki.${DOMAIN}Î°ú fallback

  # ----- Docker Hub ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§(ÏõêÍ≤©ÏóêÏÑú pullÏö©) -----
  DOCKERHUB_USER: ${{ vars.DOCKERHUB_USER }}

  # ----- Compose/ÌÖúÌîåÎ¶ø (Î°úÏª¨ Í≤ΩÎ°ú) -----
  COMPOSE_FILE:              ./mjsec-frontend/docker-compose.prod.yaml
  NGINX_HTTP_TEMPLATE_PATH:  ./mjsec-frontend/docker/nginx/default.http.conf.template
  NGINX_HTTPS_TEMPLATE_PATH: ./mjsec-frontend/docker/nginx/default.https.conf.template

jobs:
  #############################################################################
  # 1) Build & Push (GHCR) ‚Äî ÌôçÎ≥¥Ïö© ÏõπÏÇ¨Ïù¥Ìä∏(app)Îßå ÎπåÎìú/Ìë∏Ïãú
  #############################################################################
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      ghcr-tags:    ${{ steps.meta_app.outputs.tags }}
      ghcr-digest:  ${{ steps.build_app.outputs.digest }}

    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      # ----- GHCR (Î©îÏù∏ app) -----
      - name: Login to ghcr.io
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image metadata (app ‚Üí GHCR)
        id: meta_app
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build & push app image (GHCR)
        id: build_app
        uses: docker/build-push-action@v5
        with:
          context: ./mjsec-frontend
          file:    ./mjsec-frontend/Dockerfile
          push:    true
          tags:    ${{ steps.meta_app.outputs.tags }}
          cache-from: type=gha
          cache-to:   type=gha,mode=max

  #############################################################################
  # 2) Deploy (SSH + Docker Compose)
  #############################################################################
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Add host key
        run: |
          ssh-keyscan -H -p ${{ secrets.SSH_PORT }} ${{ secrets.HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "echo OK"

      # Docker HubÏóêÏÑú ÏµúÏã† ÌÉúÍ∑∏ 1Í∞úÏî© Ï°∞Ìöå (lms-back / lms-front)
      - name: Resolve latest Docker Hub tags (lms-back / lms-front)
        env:
          DH_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          DH_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          FALLBACK_USER: ${{ env.DOCKERHUB_USER }}
        run: |
          set -euo pipefail
          sudo apt-get update && sudo apt-get install -y jq

          USERNAME="${DH_USER:-$FALLBACK_USER}"
          if [ -z "$USERNAME" ]; then
            echo "Docker Hub username is missing (set secrets.DOCKERHUB_USERNAME or vars.DOCKERHUB_USER)."
            exit 1
          fi
          if [ -z "${DH_TOKEN:-}" ]; then
            echo "Docker Hub token missing (set secrets.DOCKERHUB_TOKEN)."
            exit 1
          fi

          TOKEN="$(curl -s -H "Content-Type: application/json" \
            -d "{\"username\":\"${USERNAME}\",\"password\":\"${DH_TOKEN}\"}" \
            https://hub.docker.com/v2/users/login/ | jq -r .token)"
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "Failed to get Docker Hub JWT"; exit 1
          fi

          API="https://hub.docker.com/v2/repositories"
          LATEST_BACK=$(curl -s -H "Authorization: JWT ${TOKEN}" \
            "${API}/${USERNAME}/mjsec-lms-back/tags?page_size=1&ordering=last_updated" \
            | jq -r '.results[0].name')
          LATEST_FRONT=$(curl -s -H "Authorization: JWT ${TOKEN}" \
            "${API}/${USERNAME}/mjsec-lms-front/tags?page_size=1&ordering=last_updated" \
            | jq -r '.results[0].name')

          # ÏïàÏ†ÑÌïú fallback
          if [ -z "$LATEST_BACK" ] || [ "$LATEST_BACK" = "null" ]; then LATEST_BACK="latest"; fi
          if [ -z "$LATEST_FRONT" ] || [ "$LATEST_FRONT" = "null" ]; then LATEST_FRONT="latest"; fi

          echo "LATEST_BACK=$LATEST_BACK"
          echo "LATEST_FRONT=$LATEST_FRONT"

          {
            echo "LATEST_BACK=$LATEST_BACK"
            echo "LATEST_FRONT=$LATEST_FRONT"
          } >> "$GITHUB_ENV"

      # 1) ÏõêÍ≤© ÎîîÎ†âÌÑ∞Î¶¨ Ï§ÄÎπÑ + .env ÏóÖÎ°úÎìú (LMS Î≥ÄÏàò Ìè¨Ìï®)
      - name: Prepare remote dir & .env
        run: |
          # WIKI_DOMAIN fallback
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          # ÎîîÎ†âÌÑ∞Î¶¨ ÏÉùÏÑ±
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} \
            "mkdir -p '${{ env.REMOTE_DIR }}'/nginx '${{ env.REMOTE_DIR }}'/certbot/config '${{ env.REMOTE_DIR }}'/certbot/www '${{ env.REMOTE_DIR }}'/certbot/logs '${{ env.REMOTE_DIR }}'/wikijs/db"

          # .env ÏûëÏÑ± (üëà Docker Hub ÏµúÏã† ÌÉúÍ∑∏ ÏÇ¨Ïö©)
          TMP_ENV=$(mktemp)
          cat > "$TMP_ENV" <<EOT
          ORG=${{ env.ORG }}
          REPO=${{ env.REPO }}
          DOMAIN=${{ env.DOMAIN }}
          EMAIL=${{ env.EMAIL }}
          WIKI_DOMAIN=$WIKI_DOMAIN

          # Docker Hub (pullÏö© ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ + ÌÉúÍ∑∏)
          DOCKERHUB_USER=${{ env.DOCKERHUB_USER }}
          LMS_BACK_TAG=${LATEST_BACK:-latest}
          LMS_FRONT_TAG=${LATEST_FRONT:-latest}

          # Wiki.js
          WIKI_DB_PASSWORD=${{ secrets.WIKI_DB_PASSWORD }}

          # LMS RUNTIME
          LMS_MYSQL_ROOT_PASSWORD=${{ secrets.LMS_MYSQL_ROOT_PASSWORD }}
          LMS_MYSQL_DATABASE=${{ vars.LMS_MYSQL_DATABASE }}
          LMS_MYSQL_USER=${{ vars.LMS_MYSQL_USER }}
          LMS_MYSQL_PASSWORD=${{ secrets.LMS_MYSQL_PASSWORD }}

          GMAIL_USERNAME=${{ vars.GMAIL_USERNAME }}
          GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          ADMIN_NUMBER=${{ vars.ADMIN_NUMBER }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          SPRING_PROFILES_ACTIVE=${{ vars.SPRING_PROFILES_ACTIVE || 'prod' }}

          # certbot ÏòµÏÖò
          CERTBOT_EXTRA_ARGS=--expand
          EOT
          scp -P ${{ secrets.SSH_PORT }} "$TMP_ENV" ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/.env"
          rm -f "$TMP_ENV"

      # 1-b) ÏõêÍ≤© Î†àÏßÄÏä§Ìä∏Î¶¨ Î°úÍ∑∏Ïù∏ (ÌïÑÏöî Ïãú)
      - name: Log in to ghcr.io on remote host (optional)
        run: |
          if [ -n "${{ secrets.GHCR_PAT }}" ]; then
            ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" \
              "echo '${{ secrets.GHCR_PAT }}' | docker login ghcr.io -u ${{ github.actor }} --password-stdin"
          fi

      - name: Log in to Docker Hub on remote host (optional)
        run: |
          if [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" \
              "echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u '${{ secrets.DOCKERHUB_USERNAME || env.DOCKERHUB_USER }}' --password-stdin"
          fi

      # 2) HTTP-only ÌÖúÌîåÎ¶ø & Compose ÏóÖÎ°úÎìú (ÏõêÍ≤© ÌååÏùºÎ™ÖÏùÄ docker-compose.prod.yaml Î°ú Í≥†Ï†ï)
      - name: Upload HTTP-only Nginx template and compose
        run: |
          scp -P ${{ secrets.SSH_PORT }} "${{ env.NGINX_HTTP_TEMPLATE_PATH }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"
          scp -P ${{ secrets.SSH_PORT }} "${{ env.COMPOSE_FILE }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/docker-compose.prod.yaml"

      # 3) HTTP-only Ïä§ÌÉù(Nginx+App) Í∏∞Îèô
      - name: Start HTTP-only stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml down --remove-orphans || true &&
            docker compose -f docker-compose.prod.yaml up -d nginx app
          "

      # 4) HTTP ÏùëÎãµ ÎåÄÍ∏∞
      - name: Wait for HTTP
        run: |
          for i in {1..24}; do
            if curl -sSf -m 5 http://${{ env.DOMAIN }} >/dev/null 2>&1; then
              echo 'HTTP OK'; break
            fi
            echo "...waiting HTTP (${i}/24)"; sleep 5
          done

      # 5) Ïù∏Ï¶ùÏÑú Î∞úÍ∏â/Í∞±Ïã† (Î©îÏù∏ + WIKI ÏÑúÎ∏åÎèÑÎ©îÏù∏)
      - name: Issue / Renew SSL (DOMAIN + WIKI_DOMAIN)
        run: |
          set -euo pipefail
          ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" 'bash -se' <<'EOSSH'
            set -Eeuo pipefail
            cd '${{ env.REMOTE_DIR }}'

            CERT_DIR="certbot/config/live/${{ env.DOMAIN }}"
            PEM="$CERT_DIR/fullchain.pem"
            if [ -f "$PEM" ] && openssl x509 -in "$PEM" -noout -checkend $((30*24*3600)); then
              echo "‚úÖ Certificate valid > 30 days. Skipping issuance."
              exit 0
            fi

            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: running certbot..."
              if docker compose -f docker-compose.prod.yaml run --rm certbot; then
                echo "Certbot success."
                exit 0
              fi
              sleep $((i*15))
            done
            echo "Certbot failed after retries."
            exit 1
          EOSSH

      # 6) SSL helper ÌååÏùº ÌôïÎ≥¥  (‚úÖ Ïó¨Î∂Ñ ')' Ïò§ÌÉÄ ÏàòÏ†ï)
      - name: Provide SSL helper files for nginx
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOSSH'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yaml run --rm --entrypoint "" certbot sh -euxc '
              OPTIONS=/etc/letsencrypt/options-ssl-nginx.conf
              DHPARAM=/etc/letsencrypt/ssl-dhparams.pem
              mkdir -p /etc/letsencrypt

              if [ ! -f "$OPTIONS" ]; then
                SRC=$(find /usr /opt -maxdepth 7 -type f -name options-ssl-nginx.conf | head -n1 || true)
                if [ -n "$SRC" ]; then cp "$SRC" "$OPTIONS"
                elif command -v curl >/dev/null; then
                  curl -fsSL https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf -o "$OPTIONS"
                fi
              fi
              if [ ! -s "$OPTIONS" ]; then
                printf "%s\n" \
                  "ssl_session_cache   shared:SSL:10m;" \
                  "ssl_session_timeout 1h;" \
                  "ssl_prefer_server_ciphers on;" \
                  "ssl_protocols TLSv1.2 TLSv1.3;" \
                  "ssl_ciphers EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH;" \
                  > "$OPTIONS"
              fi
              if [ ! -f "$DHPARAM" ]; then
                openssl dhparam -out "$DHPARAM" 2048
              fi
            '
          EOSSH

      # 7) HTTPS ÌÖúÌîåÎ¶ø ÏóÖÎ°úÎìú
      - name: Upload HTTPS Nginx template
        run: |
          scp -P ${{ secrets.SSH_PORT }} "${{ env.NGINX_HTTPS_TEMPLATE_PATH }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"

      # 8) conf Ïû¨ÏÉùÏÑ± & nginx reload
      - name: Apply HTTPS config & reload nginx
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml exec nginx sh -c \"
              : \\\"\\\${WIKI_DOMAIN:=wiki.\\\${DOMAIN}}\\\"; 
              envsubst '\\$DOMAIN \\$WIKI_DOMAIN' < /etc/nginx/templates/default.conf.template > /etc/nginx/conf.d/default.conf && nginx -s reload
            \"
          "

      # 9) ÏµúÏã† Ïù¥ÎØ∏ÏßÄ pull & Ï†ÑÏ≤¥ Ïä§ÌÉù Í∏∞Îèô (wiki/lms Ìè¨Ìï®)
      - name: Deploy latest stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml pull &&
            docker compose -f docker-compose.prod.yaml up -d --remove-orphans
          "
      - name: Reload nginx proxy
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml exec nginx nginx -s reload
          "

      # 10) HTTPS Í≤ÄÏ¶ù (ÎèÑÎ©îÏù∏/ÏúÑÌÇ§ + LMS ÌîÑÎ°†Ìä∏/Î∞±ÏóîÎìú Í≤ΩÎ°ú)
      - name: Verify HTTPS
        run: |
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          check() { host="$1"; path="$2"; label="$3";
            echo "Check https://$host$path ($label)"
            for i in {1..12}; do
              if curl -sSf -m 8 "https://$host$path" >/dev/null 2>&1; then
                echo "HTTPS OK: $host$path"; return 0
              fi
              echo "...waiting HTTPS (${i}/12) for $host$path"; sleep 10
            done
            return 1
          }

          check "${{ env.DOMAIN }}" "/"        "root(app)"
          check "$WIKI_DOMAIN"        "/"        "wiki"
          check "${{ env.DOMAIN }}" "/lms/"     "lms-front" || true
          curl -s -o /dev/null -m 5 "https://${{ env.DOMAIN }}/lms/api/actuator/health" \
            && echo "OK: actuator" || echo "NOTE: actuator not enabled (skip)"

      # 11) Ïò§ÎûòÎêú Ïù¥ÎØ∏ÏßÄ Ï†ïÎ¶¨
      - name: Prune images
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} \
            "docker image prune -f --filter 'until=24h' || true"

  #############################################################################
  # 3) ÏïåÎ¶º
  #############################################################################
  notify:
    needs: [ build-and-push, deploy ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Success notice
        if: success()
        run: echo "‚úÖ  Deployed to ${{ env.DOMAIN }} (+ wiki, + /lms)"

      - name: Failure notice
        if: failure()
        run: echo "‚ùå  Deployment to ${{ env.DOMAIN }} failed"
