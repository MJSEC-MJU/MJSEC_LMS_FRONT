name: CD â€“ Build, Push & Deploy to Production

on:
  push:
    branches: [ main ]
    # tags: [ 'v*.*.*' ]

permissions:
  contents: read
  packages: write

env:
  REMOTE_DIR: /srv/mjsec

  # ----- ë„ë©”ì¸/ë ˆí¬ ê¸°ë³¸ê°’ -----
  ORG:         ${{ vars.ORG }}
  REPO:        ${{ vars.REPO }}
  DOMAIN:      ${{ vars.DOMAIN }}
  EMAIL:       ${{ vars.EMAIL }}
  WIKI_DOMAIN: ${{ vars.WIKI_DOMAIN }}    # ë¹„ì–´ìˆìœ¼ë©´ wiki.${DOMAIN}ë¡œ fallback

  # ----- Docker Hub ë„¤ì„ìŠ¤í˜ì´ìŠ¤(ì›ê²©ì—ì„œ pullìš©) -----
  DOCKERHUB_USER: ${{ vars.DOCKERHUB_USER }}

  # ----- Compose/í…œí”Œë¦¿ (ë¡œì»¬ ê²½ë¡œ) -----
  COMPOSE_FILE:              ./mjsec-frontend/docker-compose.prod.yaml
  NGINX_HTTP_TEMPLATE_PATH:  ./mjsec-frontend/docker/nginx/default.http.conf.template
  NGINX_HTTPS_TEMPLATE_PATH: ./mjsec-frontend/docker/nginx/default.https.conf.template

jobs:
  #############################################################################
  # 1) Build & Push (GHCR) â€” í™ë³´ìš© ì›¹ì‚¬ì´íŠ¸(app)ë§Œ ë¹Œë“œ/í‘¸ì‹œ
  #############################################################################
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      ghcr-tags:    ${{ steps.meta_app.outputs.tags }}
      ghcr-digest:  ${{ steps.build_app.outputs.digest }}

    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      # ----- GHCR (ë©”ì¸ app) -----
      - name: Login to ghcr.io
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image metadata (app â†’ GHCR)
        id: meta_app
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build & push app image (GHCR)
        id: build_app
        uses: docker/build-push-action@v5
        with:
          context: ./mjsec-frontend
          file:    ./mjsec-frontend/Dockerfile
          push:    true
          tags:    ${{ steps.meta_app.outputs.tags }}
          cache-from: type=gha
          cache-to:   type=gha,mode=max

  #############################################################################
  # 2) Deploy (SSH + Docker Compose)
  #############################################################################
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Add host key
        run: |
          ssh-keyscan -H -p ${{ secrets.SSH_PORT }} ${{ secrets.HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "echo OK"

      # Docker Hubì—ì„œ ìµœì‹  íƒœê·¸ 1ê°œì”© ì¡°íšŒ (lms-back / lms-front)
      - name: Resolve latest Docker Hub tags (lms-back / lms-front)
        env:
          DH_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          DH_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          FALLBACK_USER: ${{ env.DOCKERHUB_USER }}
        run: |
          set -euo pipefail
          sudo apt-get update && sudo apt-get install -y jq

          USERNAME="${DH_USER:-$FALLBACK_USER}"
          if [ -z "$USERNAME" ]; then
            echo "Docker Hub username is missing (set secrets.DOCKERHUB_USERNAME or vars.DOCKERHUB_USER)."
            exit 1
          fi
          if [ -z "${DH_TOKEN:-}" ]; then
            echo "Docker Hub token missing (set secrets.DOCKERHUB_TOKEN)."
            exit 1
          fi

          TOKEN="$(curl -s -H "Content-Type: application/json" \
            -d "{\"username\":\"${USERNAME}\",\"password\":\"${DH_TOKEN}\"}" \
            https://hub.docker.com/v2/users/login/ | jq -r .token)"
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "Failed to get Docker Hub JWT"; exit 1
          fi

          API="https://hub.docker.com/v2/repositories"
          LATEST_BACK=$(curl -s -H "Authorization: JWT ${TOKEN}" \
            "${API}/${USERNAME}/mjsec-lms-back/tags?page_size=1&ordering=last_updated" \
            | jq -r '.results[0].name')
          LATEST_FRONT=$(curl -s -H "Authorization: JWT ${TOKEN}" \
            "${API}/${USERNAME}/mjsec-lms-front/tags?page_size=1&ordering=last_updated" \
            | jq -r '.results[0].name')

          # ì•ˆì „í•œ fallback
          if [ -z "$LATEST_BACK" ] || [ "$LATEST_BACK" = "null" ]; then LATEST_BACK="latest"; fi
          if [ -z "$LATEST_FRONT" ] || [ "$LATEST_FRONT" = "null" ]; then LATEST_FRONT="latest"; fi

          echo "LATEST_BACK=$LATEST_BACK"
          echo "LATEST_FRONT=$LATEST_FRONT"

          {
            echo "LATEST_BACK=$LATEST_BACK"
            echo "LATEST_FRONT=$LATEST_FRONT"
          } >> "$GITHUB_ENV"

      # 1) ì›ê²© ë””ë ‰í„°ë¦¬ ì¤€ë¹„ + .env ì—…ë¡œë“œ (LMS ë³€ìˆ˜ í¬í•¨)
      - name: Prepare remote dir & .env
        run: |
          # WIKI_DOMAIN fallback
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          # ë””ë ‰í„°ë¦¬ ìƒì„±
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} \
            "mkdir -p '${{ env.REMOTE_DIR }}'/nginx '${{ env.REMOTE_DIR }}'/certbot/config '${{ env.REMOTE_DIR }}'/certbot/www '${{ env.REMOTE_DIR }}'/certbot/logs '${{ env.REMOTE_DIR }}'/wikijs/db"

          # .env ì‘ì„± (ğŸ‘ˆ Docker Hub ìµœì‹  íƒœê·¸ ì‚¬ìš©)
          TMP_ENV=$(mktemp)
          cat > "$TMP_ENV" <<EOT
          ORG=${{ env.ORG }}
          REPO=${{ env.REPO }}
          DOMAIN=${{ env.DOMAIN }}
          EMAIL=${{ env.EMAIL }}
          WIKI_DOMAIN=$WIKI_DOMAIN

          # Docker Hub (pullìš© ë„¤ì„ìŠ¤í˜ì´ìŠ¤ + íƒœê·¸)
          DOCKERHUB_USER=${{ env.DOCKERHUB_USER }}
          LMS_BACK_TAG=${LATEST_BACK:-latest}
          LMS_FRONT_TAG=${LATEST_FRONT:-latest}

          # Wiki.js
          WIKI_DB_PASSWORD=${{ secrets.WIKI_DB_PASSWORD }}

          # LMS RUNTIME
          LMS_MYSQL_ROOT_PASSWORD=${{ secrets.LMS_MYSQL_ROOT_PASSWORD }}
          LMS_MYSQL_DATABASE=${{ vars.LMS_MYSQL_DATABASE }}
          LMS_MYSQL_USER=${{ vars.LMS_MYSQL_USER }}
          LMS_MYSQL_PASSWORD=${{ secrets.LMS_MYSQL_PASSWORD }}

          GMAIL_USERNAME=${{ vars.GMAIL_USERNAME }}
          GMAIL_APP_PASSWORD=${{ secrets.GMAIL_APP_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          ADMIN_NUMBER=${{ vars.ADMIN_NUMBER }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          SPRING_PROFILES_ACTIVE=${{ vars.SPRING_PROFILES_ACTIVE || 'prod' }}

          # certbot ì˜µì…˜
          CERTBOT_EXTRA_ARGS=--expand
          EOT
          scp -P ${{ secrets.SSH_PORT }} "$TMP_ENV" ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/.env"
          rm -f "$TMP_ENV"

      # 1-b) ì›ê²© ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë¡œê·¸ì¸ (í•„ìš” ì‹œ)
      - name: Log in to ghcr.io on remote host (optional)
        run: |
          if [ -n "${{ secrets.GHCR_PAT }}" ]; then
            ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" \
              "echo '${{ secrets.GHCR_PAT }}' | docker login ghcr.io -u ${{ github.actor }} --password-stdin"
          fi

      - name: Log in to Docker Hub on remote host (optional)
        run: |
          if [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" \
              "echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u '${{ secrets.DOCKERHUB_USERNAME || env.DOCKERHUB_USER }}' --password-stdin"
          fi

      # 2) HTTP-only í…œí”Œë¦¿ & Compose ì—…ë¡œë“œ (ì›ê²© íŒŒì¼ëª…ì€ docker-compose.prod.yaml ë¡œ ê³ ì •)
      - name: Upload HTTP-only Nginx template and compose
        run: |
          scp -P ${{ secrets.SSH_PORT }} "${{ env.NGINX_HTTP_TEMPLATE_PATH }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"
          scp -P ${{ secrets.SSH_PORT }} "${{ env.COMPOSE_FILE }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/docker-compose.prod.yaml"

      # 3) HTTP-only ìŠ¤íƒ(Nginx+App) ê¸°ë™
      - name: Start HTTP-only stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml down --remove-orphans || true &&
            docker compose -f docker-compose.prod.yaml up -d nginx app
          "

      # 4) HTTP ì‘ë‹µ ëŒ€ê¸°
      - name: Wait for HTTP
        run: |
          for i in {1..24}; do
            if curl -sSf -m 5 http://${{ env.DOMAIN }} >/dev/null 2>&1; then
              echo 'HTTP OK'; break
            fi
            echo "...waiting HTTP (${i}/24)"; sleep 5
          done

      # 5) ì¸ì¦ì„œ ë°œê¸‰/ê°±ì‹  (ë©”ì¸ + WIKI ì„œë¸Œë„ë©”ì¸)
      - name: Issue / Renew SSL (DOMAIN + WIKI_DOMAIN)
        run: |
          set -euo pipefail

          # GitHub Actions í‘œí˜„ì‹ì— ê¸°ë³¸ê°’(:-) ì“°ì§€ ë§ê³  bashì—ì„œ ì²˜ë¦¬
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then
            WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"
          fi
          echo "Using WIKI_DOMAIN=$WIKI_DOMAIN"

          # ì›ê²© ì‹¤í–‰ (ì¢…ë£Œì½”ë“œ ìº¡ì²˜)
          set +e
          ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.USER }}@${{ secrets.HOST }}" 'bash -se' <<'EOF'
            set -Eeuo pipefail
            cd '${{ env.REMOTE_DIR }}'

            # í•„ìš” ì‹œì—ë§Œ ë°œê¸‰/ê°±ì‹  ì‹œë„ (30ì¼ ì´ìƒ ë‚¨ìœ¼ë©´ skip)
            CERT_DIR="certbot/config/live/${{ env.DOMAIN }}"
            PEM="$CERT_DIR/fullchain.pem"
            if [ -f "$PEM" ] && openssl x509 -in "$PEM" -noout -checkend $((30*24*3600)); then
              echo "âœ… Certificate valid > 30 days. Skipping issuance."
              exit 0
            fi

            # ì¬ì‹œë„(ìµœëŒ€ 5íšŒ)
            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: running certbot..."
              if docker compose -f docker-compose.prod.yaml run --rm certbot; then
                echo "Certbot success."
                exit 0
              fi
              sleep $((i*15))
            done

            echo "Certbot failed after retries."
            exit 1
          EOF
          RC=$?
          set -e

          echo "Remote exit code: $RC"
          exit $RC

      # 6) SSL helper íŒŒì¼ í™•ë³´ 
      - name: Provide SSL helper files for nginx
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yaml run --rm --entrypoint "" certbot sh -euxc '
              OPTIONS=/etc/letsencrypt/options-ssl-nginx.conf
              DHPARAM=/etc/letsencrypt/ssl-dhparams.pem
              mkdir -p /etc/letsencrypt

              if [ ! -f "$OPTIONS" ]; then
                SRC=$(find /usr /opt -maxdepth 7 -type f -name options-ssl-nginx.conf | head -n1 || true)
                if [ -n "$SRC" ]; then cp "$SRC" "$OPTIONS"
                elif command -v curl >/dev/null; then
                  curl -fsSL https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf -o "$OPTIONS"
                fi
              fi
              if [ ! -s "$OPTIONS" ]; then
                printf "%s\n" \
                  "ssl_session_cache   shared:SSL:10m;" \
                  "ssl_session_timeout 1h;" \
                  "ssl_prefer_server_ciphers on;" \
                  "ssl_protocols TLSv1.2 TLSv1.3;" \
                  "ssl_ciphers EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH;" \
                  > "$OPTIONS"
              fi
              if [ ! -f "$DHPARAM" ]; then openssl dhparam -out "$DHPARAM" 2048; fi
            '
          EOF

      # 7) HTTPS í…œí”Œë¦¿ ì—…ë¡œë“œ
      - name: Upload HTTPS Nginx template
        run: |
          scp -P ${{ secrets.SSH_PORT }} "${{ env.NGINX_HTTPS_TEMPLATE_PATH }}" \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"

      # 8) conf ì¬ìƒì„± & nginx reload
      - name: Apply HTTPS config & reload nginx
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yaml exec nginx sh -c '
              : "${WIKI_DOMAIN:=wiki.$DOMAIN}";
              envsubst '\''$DOMAIN $WIKI_DOMAIN'\'' < /etc/nginx/templates/default.conf.template \
                > /etc/nginx/conf.d/default.conf && nginx -s reload
            '
          EOF

      # 9) ìµœì‹  ì´ë¯¸ì§€ pull & ì „ì²´ ìŠ¤íƒ ê¸°ë™ (wiki/lms í¬í•¨)
      - name: Deploy latest stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml pull &&
            docker compose -f docker-compose.prod.yaml up -d --remove-orphans
          "
      - name: Reload nginx proxy
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml exec nginx nginx -s reload
          "

      # 10) HTTPS ê²€ì¦ (ë„ë©”ì¸/ìœ„í‚¤ + LMS í”„ë¡ íŠ¸/ë°±ì—”ë“œ ê²½ë¡œ)
      - name: Verify HTTPS
        run: |
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          check() { host="$1"; path="$2"; label="$3";
            echo "Check https://$host$path ($label)"
            for i in {1..12}; do
              if curl -sSf -m 8 "https://$host$path" >/dev/null 2>&1; then
                echo "HTTPS OK: $host$path"; return 0
              fi
              echo "...waiting HTTPS (${i}/12) for $host$path"; sleep 10
            done
            return 1
          }

          check "${{ env.DOMAIN }}" "/"        "root(app)"
          check "$WIKI_DOMAIN"        "/"        "wiki"
          check "${{ env.DOMAIN }}" "/lms/"     "lms-front" || true
          curl -s -o /dev/null -m 5 "https://${{ env.DOMAIN }}/lms/api/actuator/health" \
            && echo "OK: actuator" || echo "NOTE: actuator not enabled (skip)"

      # 11) ì˜¤ë˜ëœ ì´ë¯¸ì§€ ì •ë¦¬
      - name: Prune images
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} \
            "docker image prune -f --filter 'until=24h' || true"

  #############################################################################
  # 3) ì•Œë¦¼
  #############################################################################
  notify:
    needs: [ build-and-push, deploy ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Success notice
        if: success()
        run: echo "âœ…  Deployed to ${{ env.DOMAIN }} (+ wiki, + /lms)"

      - name: Failure notice
        if: failure()
        run: echo "âŒ  Deployment to ${{ env.DOMAIN }} failed"
