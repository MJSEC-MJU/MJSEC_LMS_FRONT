name: CD – Build, Push & Deploy to Production

on:
  push:
    branches: [ main ]
    # tags: [ 'v*.*.*' ]

permissions:
  contents: read
  packages: write

env:
  REMOTE_DIR: /srv/mjsec
  ORG:        ${{ vars.ORG }}
  REPO:       ${{ vars.REPO }}
  DOMAIN:     ${{ vars.DOMAIN }}
  EMAIL:      ${{ vars.EMAIL }}
  # 선택: 비워두면 자동으로 wiki.${DOMAIN} 사용 (쉘에서 fallback 처리)
  WIKI_DOMAIN: ${{ vars.WIKI_DOMAIN }}

jobs:
  #############################################################################
  # 1) Build & Push (GHCR)
  #############################################################################
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag:    ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: Login to ghcr.io
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build & push frontend image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./mjsec-frontend
          file:    ./mjsec-frontend/Dockerfile
          push:    true
          tags:    ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to:   type=gha,mode=max

  #############################################################################
  # 2) Deploy (SSH + Docker Compose)
  #############################################################################
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Add host key
        run: |
          ssh-keyscan -H -p ${{ secrets.SSH_PORT }} ${{ secrets.HOST }} >> ~/.ssh/known_hosts

      - name: Test SSH
        run: ssh -o ConnectTimeout=10 -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "echo OK"

      # 1) 원격 디렉터리 + .env 작성
      - name: Prepare remote directory & .env
        run: |
          # 로컬에서 WIKI_DOMAIN fallback 계산
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
            mkdir -p "${{ env.REMOTE_DIR }}"/{nginx,certbot/{config,www,logs},wikijs/db}
          EOF

          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} <<EOF
            cat > "${{ env.REMOTE_DIR }}/.env" <<EOT
            ORG=${{ env.ORG }}
            REPO=${{ env.REPO }}
            DOMAIN=${{ env.DOMAIN }}
            EMAIL=${{ env.EMAIL }}
            WIKI_DOMAIN=${WIKI_DOMAIN}
            # Wiki.js DB 비밀번호 (GitHub Secrets에서 주입)
            WIKI_DB_PASSWORD=${{ secrets.WIKI_DB_PASSWORD }}
            # 단일 인증서 → 다중 도메인 확장 시 안전하게 사용
            CERTBOT_EXTRA_ARGS=--expand
            EOT
          EOF

      # 1-b) 원격 GHCR 로그인(pull용)
      - name: Log in to ghcr.io on remote host
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            if [ -n \"${{ secrets.GHCR_PAT }}\" ]; then
              echo '${{ secrets.GHCR_PAT }}' \
                | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            fi
          "

      # 2) HTTP-only 템플릿 & Compose 업로드
      - name: Upload HTTP-only Nginx template and compose
        run: |
          scp -P ${{ secrets.SSH_PORT }} mjsec-frontend/docker/nginx/default.http.conf.template \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"
          scp -P ${{ secrets.SSH_PORT }} mjsec-frontend/docker-compose.prod.yaml \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/"

      # 3) HTTP-only 스택(Nginx+App) 기동
      - name: Start HTTP-only stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml down --remove-orphans || true &&
            docker compose -f docker-compose.prod.yaml up -d nginx app
          "

      # 4) HTTP 응답 대기
      - name: Wait for HTTP
        run: |
          for i in {1..24}; do
            if curl -sSf -m 5 http://${{ env.DOMAIN }} >/dev/null 2>&1; then
              echo 'HTTP OK'; break
            fi
            echo "...waiting HTTP (${i}/24)"; sleep 5
          done

      # 5) 인증서 발급/갱신 (메인 + WIKI 서브도메인) — Compose entrypoint 사용
      - name: Issue / Renew SSL (DOMAIN + WIKI_DOMAIN) if needed
        run: |
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"; [ -z "$WIKI_DOMAIN" ] && WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} <<'EOF'
            set -e
            cd '${{ env.REMOTE_DIR }}'
            CERT_DIR="certbot/config/live/${{ env.DOMAIN }}"
            PEM="$CERT_DIR/fullchain.pem"

            # 1) 이미 30일 이상 유효하면 스킵
            if [ -f "$PEM" ] && openssl x509 -in "$PEM" -noout -checkend $((30*24*3600)); then
              echo "✅ Certificate valid > 30 days. Skipping issuance."
              exit 0
            fi

            # 2) 재시도(최대 5회, 지수 백오프)
            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: running certbot..."
              if docker compose -f docker-compose.prod.yaml run --rm certbot; then
                echo "✅ Certbot success."
                exit 0
              fi
              S=$((i*15))
              echo "⚠️  Certbot failed. Sleeping ${S}s before retry..."
              sleep $S
            done

            echo "❌  Certbot failed after retries."
            exit 1
          EOF

      # 6) SSL helper 파일 확보
      - name: Provide SSL helper files for nginx
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yaml run --rm --entrypoint "" certbot sh -euxc '
              OPTIONS=/etc/letsencrypt/options-ssl-nginx.conf
              DHPARAM=/etc/letsencrypt/ssl-dhparams.pem
              mkdir -p /etc/letsencrypt

              if [ ! -f "$OPTIONS" ]; then
                SRC=$(find /usr /opt -maxdepth 7 -type f -name options-ssl-nginx.conf | head -n1 || true)
                if [ -n "$SRC" ]; then cp "$SRC" "$OPTIONS"
                elif command -v curl >/dev/null; then
                  curl -fsSL https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf -o "$OPTIONS"
                fi
              fi
              if [ ! -s "$OPTIONS" ]; then
                printf "%s\n" \
                  "ssl_session_cache   shared:SSL:10m;" \
                  "ssl_session_timeout 1h;" \
                  "ssl_prefer_server_ciphers on;" \
                  "ssl_protocols TLSv1.2 TLSv1.3;" \
                  "ssl_ciphers EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH;" \
                  > "$OPTIONS"
              fi
              if [ ! -f "$DHPARAM" ]; then openssl dhparam -out "$DHPARAM" 2048; fi
            '
          EOF

      # 7) HTTPS 템플릿 업로드
      - name: Upload HTTPS Nginx template
        run: |
          scp -P ${{ secrets.SSH_PORT }} mjsec-frontend/docker/nginx/default.https.conf.template \
            ${{ secrets.USER }}@${{ secrets.HOST }}:"${{ env.REMOTE_DIR }}/nginx/default.conf.template"

      # 8) conf 재생성 & nginx reload (DOMAIN + WIKI_DOMAIN)
      - name: Apply HTTPS config & reload nginx
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
            cd '${{ env.REMOTE_DIR }}'
            docker compose -f docker-compose.prod.yaml exec nginx sh -c '
              : "${WIKI_DOMAIN:=wiki.$DOMAIN}";
              envsubst '\''$DOMAIN $WIKI_DOMAIN'\'' < /etc/nginx/templates/default.conf.template \
                > /etc/nginx/conf.d/default.conf && nginx -s reload
            '
          EOF

      # 9) 최신 이미지 pull & 전체 스택 기동 (wiki 포함)
      - name: Deploy latest stack
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml pull &&
            docker compose -f docker-compose.prod.yaml up -d --remove-orphans
          "
      - name: Reload nginx proxy
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} "
            cd '${{ env.REMOTE_DIR }}' &&
            docker compose -f docker-compose.prod.yaml exec nginx nginx -s reload
          "

      # 10) HTTPS 검증 (두 도메인)
      - name: Verify HTTPS (DOMAIN + WIKI_DOMAIN)
        run: |
          WIKI_DOMAIN="${{ env.WIKI_DOMAIN }}"
          if [ -z "$WIKI_DOMAIN" ]; then WIKI_DOMAIN="wiki.${{ env.DOMAIN }}"; fi

          for host in "${{ env.DOMAIN }}" "$WIKI_DOMAIN"; do
            echo "Check https://$host"
            for i in {1..12}; do
              if curl -sSf -m 5 "https://$host" >/dev/null 2>&1; then
                echo "HTTPS OK: $host"; break
              fi
              echo "...waiting HTTPS (${i}/12) for $host"; sleep 10
            done
          done

      # 11) 오래된 이미지 정리
      - name: Prune images
        run: |
          ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.USER }}@${{ secrets.HOST }} \
            "docker image prune -f --filter 'until=24h' || true"

  #############################################################################
  # 3) 알림
  #############################################################################
  notify:
    needs: [ build-and-push, deploy ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Success notice
        if: success()
        run: echo "✅  Deployed to ${{ env.DOMAIN }} (+ wiki)"

      - name: Failure notice
        if: failure()
        run: echo "❌  Deployment to ${{ env.DOMAIN }} failed"
